Machine Language

## 程序的机器级表示

### 编译过程
以GCC编译C语言为例
linux> `gcc -Og -o hello hello.c`
(-Og 优化等级低，避免机器代码严重变形，便于进行调试)
1. 预处理：将预处理指令进行替换 (头文件包含，宏展开，条件编译`#if #ifdef #endif...`)，删除注释，得到处理后的`.i`C代码
2. 编译：将`.i`文件进行编译得到`.s`汇编语言文件
3. 汇编：将`.s`翻译成机器指令，得到二进制文件 (windows下`.obj` linux下`.o`)
4. 链接：将`.o`文件和所需要的库文件组合在一起(头文件的函数在预处理中只声明，链接定位函数的具体实现)，生成可执行文件

linux> `gcc -Og -S hello.c` 产生一个汇编文件 `hello.s`
linux> `gcc -Og -c hello.c` 产生二进制文件`hello.o`
linux> `objdump -d hello.o` 实现反汇编

### 机器级代码概述
*指令集架构(ISA Instruction Set Architecture)* 定义机器级代码的格式和行为，虽然指令在ISA层面被描述为顺序执行，但现代处理器采用流水线、乱序执行等技术实现并发执行，最终结果与顺序执行一致
x86系列：`8086`(16位架构) $\rightarrow$ `IA-32` (32位架构) $\rightarrow$ `x86-64`(64位架构)
机器级程序使用多个硬件存储器组成的虚拟地址，操作系统负责将虚拟地址翻译成对应的物理地址
一条机器代码一般只执行非常基本的操作，如寄存器中两个数相加，存储器与寄存器之间传送数据，条件分支转移到新的指令地址等

汇编代码格式：`AT&T`与`Intel`
1. Intel 代码省略了指示大小的后缀:`movq` $\rightarrow$ `mov`
2. Intel 代码省略寄存器前面的"%":`%rax` $\rightarrow$ `rax`
3. Intel 代码描述内存的方式不同:`(%rax)` $\rightarrow$ `QWORD PTR [rax]`
4. Intel 与 AT&T列出操作数的顺序相反: `movq %rax, %rbx` $\rightarrow$ `mov rbx, rax`

**本文采用x86-64 AT&T格式**

机器代码的优势：性能优化，访问硬件特性(PC,寄存器)，更难逆向分析

### 数据的传输
#### 数据格式
最初的架构为16位，所以Intel用 **字(word)** 表示16位，32位为**双字(double words/long word)**，64位为**四字(quad words)**

![Screenshot_2025-11-10-22-07-36-853_com.orion.note](https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001815900-1786188252.png)

GCC生成的部分汇编代码指令都带有一个字符后缀表示操作的大小，如`movl`表示传送双字

#### 信息访问
x86-64 CPU 中含有16个通用寄存器

![Screenshot_2025-11-10-22-16-23-354_com.orion.note](https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001844364-235284147.png)

8086中含有`%ax`到`%sp`8个通用寄存器
IA32将这8个寄存器扩展为32位 (`%eax`中的"e":extended)
x86-64将寄存器扩展到64位(`%rax`中的"r":register整个寄存器)，并采用新的命名方式增加8个寄存器(`%r8`～`%r15`，`%r8d`中的"d":double words，`%r8w`中的"w":word)
指令通过不同的后缀大小(b,w,l,q)，得以访问寄存器的不同最低字节(1,2,4,8)
小于8字节的数据传送到寄存器中时，若传送字节为1或2，则更高的字节不变；若传送字节为4，则更高的4个字节全置为0(IA32到x86-64扩展导致的)

#### 操作数指示符
将寄存器看做数组$R[]$，内存看做数组$M[]$
1. 立即数(immediate):`$`后面接常数 *eg.* `$114514`
2. 寄存器(register):以指定寄存器的低位1,2,4,8字节为操作数，返回寄存器中的值即$R[r_a]$ *eg.* `%eax`返回第一个寄存器的低32位
3. 内存引用：将内存看做很大的字节数组，根据计算的有效地址访问内存位置

内存引用的寻址模式：$Imm(r_b,r_i,s)$，其中$Imm$为立即数偏移，$r_b$和$r_i$为64位寄存器，$s$取1,2,4,8(默认为1)
有效地址被计算为$addr=Imm+R[r_b]+R[r_i]*s$，返回$M[addr]$

![Screenshot_2025-11-10-23-29-52-688_com.orion.note](https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001939000-1074886966.png)


#### 数据传送指令
将数据从一个位置传送到另一个位置的指令
##### MOV
`MOV S, D`指将数据从$S$复制到$D$，其中$S$称为源操作数，$D$称为目的操作数

![Screenshot_2025-11-10-23-38-16-834_com.orion.note](https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001911521-1773120295.png)


其中源操作数可以取立即数，寄存器，内存；目的操作数可以取寄存器和内存
注意：x86架构中大部分操作(包括`MOV`)源操作数和目的操作数不能同时为内存，必须通过寄存器进行中转
$movabsq$作用：处理立即数时，$movq$只能传送32位立即数然后在符号扩展到64位，而$movabsq$能将64位立即数直接传送到寄存器，但只能移动立即数

![Screenshot_2025-11-10-23-47-23-335_com.orion.note](https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111002047369-2136489101.png)


##### MOVZ与MOVS
两者都是将较小源值复制到较大的目的值，后缀都有两个大小指示符，分别是源的大小和目的的大小
`MOVZ` 采用零扩展进行复制，无符号数扩展
![Screenshot_2025-11-10-23-52-13-161_com.orion.note](https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111002001201-1699065042.png)

注：没有`movzlq`的原因是使用`movl`传送4个字节会把前面更高的4个字节全赋为0，两者等价

`MOVS`采用符号扩展进行复制，有符号数扩展

![Screenshot_2025-11-10-23-52-52-878_com.orion.note](https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111002015850-163942126.png)