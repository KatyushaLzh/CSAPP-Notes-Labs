## 程序的机器级表示

### 编译过程

以GCC编译C语言为例
linux> `gcc -Og -o hello hello.c`
(-Og 优化等级低，避免机器代码严重变形，便于进行调试)

1. 预处理：将预处理指令进行替换 (头文件包含，宏展开，条件编译`#if #ifdef #endif...`)，删除注释，得到处理后的`.i`C代码
2. 编译：将`.i`文件进行编译得到`.s`汇编语言文件
3. 汇编：将`.s`翻译成机器指令，得到二进制文件 (windows下`.obj` linux下`.o`)
4. 链接：将`.o`文件和所需要的库文件组合在一起(头文件的函数在预处理中只声明，链接定位函数的具体实现)，生成可执行文件

linux> `gcc -Og -S hello.c` 产生一个汇编文件 `hello.s`
linux> `gcc -Og -c hello.c` 产生二进制文件`hello.o`
linux> `objdump -d hello.o` 实现反汇编

### 机器级代码概述

*指令集架构(ISA Instruction Set Architecture)* 定义机器级代码的格式和行为，虽然指令在ISA层面被描述为顺序执行，但现代处理器采用流水线、乱序执行等技术实现并发执行，最终结果与顺序执行一致
x86系列：`8086`(16位架构) $\rightarrow$ `IA-32` (32位架构) $\rightarrow$ `x86-64`(64位架构)
机器级程序使用多个硬件存储器组成的虚拟地址，操作系统负责将虚拟地址翻译成对应的物理地址
一条机器代码一般只执行非常基本的操作，如寄存器中两个数相加，存储器与寄存器之间传送数据，条件分支转移到新的指令地址等

汇编代码格式：`AT&T`与`Intel`

1. Intel 代码省略了指示大小的后缀:`movq` $\rightarrow$ `mov`
2. Intel 代码省略寄存器前面的"%":`%rax` $\rightarrow$ `rax`
3. Intel 代码描述内存的方式不同:`(%rax)` $\rightarrow$ `QWORD PTR [rax]`
4. Intel 与 AT&T列出操作数的顺序相反: `movq %rax, %rbx` $\rightarrow$ `mov rbx, rax`

**本文采用x86-64 AT&T格式**

机器代码的优势：性能优化，访问硬件特性(PC,寄存器)，更难逆向分析

### 数据的传输

#### 数据格式

最初的架构为16位，所以Intel用 **字(word)** 表示16位，32位为**双字(double words/long word)**，64位为**四字(quad words)**

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001815900-1786188252.png" style="zoom:50%" alt=""/></div>

GCC生成的部分汇编代码指令都带有一个字符后缀表示操作的大小，如`movl`表示传送双字

#### 信息访问

x86-64 CPU 中含有16个通用寄存器

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001844364-235284147.png" style="zoom:30%" alt=""/></div>

8086中含有`%ax`到`%sp`8个通用寄存器
IA32将这8个寄存器扩展为32位 (`%eax`中的"e":extended)
x86-64将寄存器扩展到64位(`%rax`中的"r":register整个寄存器)，并采用新的命名方式增加8个寄存器(`%r8`～`%r15`，`%r8d`中的"d":double words，`%r8w`中的"w":word)
指令通过不同的后缀大小(b,w,l,q)，得以访问寄存器的不同最低字节(1,2,4,8)
小于8字节的数据传送到寄存器中时，若传送字节为1或2，则更高的字节不变；若传送字节为4，则更高的4个字节全置为0(IA32到x86-64扩展导致的)

#### 操作数指示符

将寄存器看做数组$R[]$，内存看做数组$M[]$

1. 立即数(immediate):`$`后面接常数 *eg.* `$114514`
2. 寄存器(register):以指定寄存器的低位1,2,4,8字节为操作数，返回寄存器中的值即$R[r_a]$ *eg.* `%eax`返回第一个寄存器的低32位
3. 内存引用：将内存看做很大的字节数组，根据计算的有效地址访问内存位置

内存引用的寻址模式：$Imm(r_b,r_i,s)$，其中$Imm$为立即数偏移，$r_b$和$r_i$为64位寄存器，$s$取1,2,4,8(默认为1)
有效地址被计算为$addr=Imm+R[r_b]+R[r_i]*s$，返回$M[addr]$

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001939000-1074886966.png" style="zoom:50%" alt=""/></div>

#### 数据传送指令

将数据从一个位置传送到另一个位置的指令

##### MOV

`MOV S, D`指将数据从$S$复制到$D$，其中$S$称为源操作数，$D$称为目的操作数

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111001911521-1773120295.png" style="zoom:50%" alt=""/></div>

其中源操作数可以取立即数，寄存器，内存；目的操作数可以取寄存器和内存
注意：x86架构中大部分操作(包括`MOV`)源操作数和目的操作数不能同时为内存，必须通过寄存器进行中转
$movabsq$作用：处理立即数时，$movq$只能传送32位立即数然后在符号扩展到64位，而$movabsq$能将64位立即数直接传送到寄存器，但只能移动立即数

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111002047369-2136489101.png" style="zoom:50%" alt=""/></div>

##### MOVZ与MOVS

两者都是将较小源值复制到较大的目的值，后缀都有两个大小指示符，分别是源的大小和目的的大小
`MOVZ` 采用零扩展进行复制，无符号数扩展

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111002001201-1699065042.png" style="zoom:50%" alt=""/></div>

注：没有`movzlq`的原因是使用`movl`传送4个字节会把前面更高的4个字节全赋为0，两者等价

`MOVS`采用符号扩展进行复制，有符号数扩展

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111002015850-163942126.png" style="zoom:50%" alt=""/></div>

##### 压入和弹出栈数据

x86-64架构中，程序栈放在内存中某个区域，寄存器`%rsp`保存栈顶的地址
不同于C语言中用数组模拟实现栈时栈顶指针指向地址最高，`%rsp`指向的栈顶地址是栈中最小的

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111211300777-213601249.png" style="zoom:50%" alt=""/></div>

`pushq %rbp`等价于`subq $8,%rsp movq %rbp,(%rsp)`，即将栈顶指针向前移动8个字节，再将元素入栈
`pushq`的优势：编码为1个字节，而等价代码编码为8个字节；同时现代x86-64处理器上`pushq`被高度优化，效率更高
栈内数据在内存中，同样可以用内存寻址法访问


#### 算术和逻辑操作

四类操作：加载有效地址，一元操作，二元操作，移位
除去$leaq$只能用于8字节以外，其他指令都能用不同后缀(b,w,l,q)指示操作大小

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251111212640909-602193721.png" style="zoom:40%" alt=""/></div>

##### 加载有效地址

lea:load effective address
$leaq Imm(r_b,r_i,s), r_d$ 表示采用内存计算的方法算出地址之后，将该有效地址作为数字直接存储到$r_d$中
*eg.* 设`%rbx`的值为$x$，则 `leaq 6(%rbx,%rbx,4), %rax` 表示计算$5 \times x + 6$并存放在$%rax$中
作用：简洁地表示普通的算术操作

##### 一元操作和二元操作

一元操作中的操作数既是源操作数又是目的操作数；二元操作中前者为源操作数，后者为目的操作数
*eg.* `subq %rbx,%rax`表示将$R[rax]$减去$R[rbx]$
同样，二元操作也不能源和目的都为内存，需要进行寄存器的中转

##### 移位操作

`SAR`表示算术右移(Shift Arithmetic Right)，`SHR`表示逻辑右移
为了对称，同时有`SAL`和`SHL`，但是两者作用完全等价，`SHL`更为常用
移位操作有两个操作数，前者为移位数(立即数或者`%cl`中的数 **不能是其他寄存器或内存中的数**)，后者为移位的对象(内存或寄存器)
注：移位操作实际使用的移位位数为指令大小后缀对应的低位，如$sarl$实际移位数位给定数对32取模
*eg.* `shlq $65 %rax` 即为将`％rax`中的数左移1位

##### 特殊算术操作

两个64位整数相乘时需要得到128位整数再进行截断，其中16字节的数称为八字(oct words)

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251112000552730-2101802702.png" style="zoom:30%" alt=""/></div>

`imulq` 的第一种形式：`imulq S, D` 将 `D` 乘以 `S`，结果存储在 `D` 中
`imulq`的第二种形式：`IMUL S`，另一个参数在`%rax`中，乘积得到的128位结果高64位放在`%rdx`中，低64位放在`%rax`中($\_\_int128$)

`idivq`(有符号除法):将`%rdx`看做高64位，`%rax`看做低64位得到128位被除数，除数作为指令操作数给出，商存放在`%rax`中，余数存放在`%rdx`中
当被除数为64位时，`cqto`指令通过符号扩展将被除数扩展到128位

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251112002403189-1854304306.png" style="zoom:50%" alt=""/></div>
<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202511/2454100-20251112002406910-1611158881.png" style="zoom:50%" alt=""/></div>

`divq`(无符号除法)：事先将`%rdx`设置为0，可以使用`xorq %rdx, %rdx`

