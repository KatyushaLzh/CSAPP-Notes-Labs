[TOC]

## 异常控制流
假设处理器工作时，PC指向的指令地址构成的序列为$a_1,a_2...a_n$，序列$a$就称为处理器的控制流，由$a_i$向$a_{i+1}$的过渡称为控制转移
现代系统通过使控制流发生突变，对系统状态的变化做出反应，这些突变就称为异常控制流(Exceptional Control Flow，**ECF**)

### 异常
异常是一种相应处理器变化的机制既有软件实现的部分，也有硬件实现的部分
其机制如下

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251221231152016-632874585.jpg" style="zoom:35%" alt=""/></div>

假设处理器正在执行指令$I_{cur}$，此时发生一个事件(如除0，数值溢出，直接内存访问结束)，处理器会检测到该事件的发生，并通过异常表发生控制转移，跳转到相应的异常处理程序进行处理，然后返回继续执行指令或终止程序

#### 异常的识别与调用
每一种异常都有着一个唯一的无符号数表示的异常号
在系统启动时，系统会生成一张异常表，该表的第$k$项存放了对应异常号为$k$的异常处理程序指令所在地址
而异常处理程序的调用类似于函数，但是有着一些区别：
1. 调用函数后，条件码等信息可能发生变化；调用异常处理程序时这些信息进行了压栈保存，处理结束后弹出，保证了程序的正常运行
2. 调用函数会将返回地址压入用户栈中；而调用异常处理程序会将返回地址和相关信息压入内核栈
3. 函数运行在用户模式下；而异常处理程序运行在内核模式下，有着对系统资源更完全的访问权

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251221232928584-1713770092.jpg" style="zoom:40%" alt=""/></div>

#### 异常的类型
异常有以下四种类型：**中断**，**陷阱**，**故障**，**终止**
其中中断属于**异步异常**，而其他三种属于**同步异常**

##### 中断
外部I/O设备发出信号，导致中断发生。即中断不是由内部指令造成的，所以称为异步异常
I/O设备通过向处理器芯片上的引脚发信号，并将异常号放入系统总线中进而触发中断
其流程如下：

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251221231152016-632874585.jpg" style="zoom:40%" alt=""/></div>

我们以DMA直接内存访问结束为例，当磁盘访问完成时，处理器收到了对应的异常码，在调用异常处理程序后继续处理下一条指令

##### 陷阱
陷阱是有意造成的异常，和中断相似，但区别在于是由内部指令造成的
陷阱最重要的作用是**系统调用**，这是用户程序和内核间的接口，通过访问内核，得以进行文件读写，创建进程等重要操作
汇编中，使用`syscall`进行系统调用，触发一个到异常处理程序的陷阱

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251221234652979-1470183206.jpg" style="zoom:40%" alt=""/></div>

##### 故障
故障是处理器处理中出现了错误情况，它可能在被异常处理程序修正后成功重新运行(如缺页异常)，也可能无法被修复导致程序终止

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251221231152016-632874585.jpg" style="zoom:40%" alt=""/></div>

注意：导致故障时当前指令尚未完成，所以如果成功修复后，需要跳转到当前指令重新执行，而非下一条指令

##### 终止
发生了不可修复的严重错误，不返回控制，直接返回会结束该程序的`abort`例程

#### linux系统中的异常
我们以x86-64为例，有256种异常指令，其中0～31由架构定义，对x86-64架构都一样；而32～255由操作系统定义，都是中断和陷阱

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251221235928533-1927567517.jpg" style="zoom:40%" alt=""/></div>

其中除法错误和一般保护故障(段错误)虽然在硬件层面上是完全可修复的，但是在软件层面属于逻辑错误，为了便于调试查错，直接会导致程序终止暴露错误而非静默修复

linux为系统调用生成了一张跳转表，每个系统调用都有一个唯一的整数号
汇编语言中，进行系统调用时，将要进行的系统调用的整数号放入$\%rax$中，参数最多六个，依次放入$\%rdi \%rsi \%rdx \%r10 \%r8 \%r9$中，然后使用指令`syscall`即可
进行系统调用时，$\%rcx \%r11$会被用作临时变量，分别保存下一条指令地址和程序状态标志而被破坏掉
调用结束后的返回值会覆盖$\%rax$，当其值为负数时，说明系统调用发生了错误

常见系统调用的跳转表如下
<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251222001524360-2107642834.jpg" style="zoom:40%" alt=""/></div>

hello world 汇编实现
<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251222001702725-419118547.jpg" style="zoom:30%" alt=""/></div>

事实上，函数调用在高级语言中被高度封装成了函数(如`write`封装为`printf`)，但是我们也可以通过相关接口直接进行系统调用

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251222002122452-1086072796.jpg" style="zoom:40%" alt=""/></div>

### 进程
程序是一个静态的文件，而进程则是程序运行起来的动态的实例
上下文是程序运行所需要的各种状态，包括代码，数据，PC，运行栈等，程序在进程的上下文中运行

#### 逻辑控制流
我们以单核处理器为例，假设某一时刻存在多个进程都需要运行，处理器在一个时间点上只能推进一个进程
处理器通过短暂，频繁地中断和切换其处理的进程，创造出一种所有进程都在同时进行的宏观表象

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251222002901149-873750357.jpg" style="zoom:40%" alt=""/></div>

实际上，进程轮流占有处理器，执行一段时间后被抢占，其他进程进行处理。从宏观上来看，就好像每个进程都独占处理器，只是中间发生一些周期性的停顿

#### 并发流
当两个进程运行的时间有交集时，就称这两个进程**并发**运行
当两个进程并发地运行在不同的处理器1核或者计算机上时，就称这两个进程**并行**运行
并发和并行最终都达到了**多任务**的结果

#### 私有地址空间
操作系统通过为每个进程分配虚拟地址空间，使得宏观上就像每个进程占用整个系统地址空间

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251222003736827-1626083880.jpg" style="zoom:30%" alt=""/></div>

#### 用户模式和内核模式
用户模式限制了应用可以执行的指令和访问的地址空间
在控制寄存器中，存在一位模式位，当这一位被设置时，进程就处于内核模式，可以执行任何指令集中的指令，访问内存中的任意空间
反之，进程处于用户模式，必须通过异常在异常处理程序中处于内核模式进行操作，然后再回到用户模式中
在linux中，`/proc`和`/sys`中存放了内核的信息，大部分只读，小部分可写

#### 上下文切换
内核为每个进程都维护了一个上下文，当需要切换该进程执行时，恢复上下文并控制传递给这个进程即可
在进程执行时，内核中的一段称为调度器的代码进行调度的决策，即决定是否对某个正在执行的进程进行抢占，转而执行其他被挂起的进程
例如，当一个进程需要进行磁盘写的时候，调度器可以先将此进程挂起，上下文切换执行其他进程，当直接内存访问完成后再转而执行该进程
中断也可能引起上下文切换，如系统都能周期性地发出中断信号，让内核判定当前进程已经进行了较长时间，应该进行上下文切换

<div align="center"><img src="https://img2024.cnblogs.com/blog/2454100/202512/2454100-20251222005433619-493679084.jpg" style="zoom:30%" alt=""/></div>

------------